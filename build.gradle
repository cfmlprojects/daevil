plugins {
    id 'com.github.johnrengelman.shadow' version '7.1.2'
    id "org.asciidoctor.convert" version "1.5.7"
    id "org.ajoberstar.grgit" version "5.2.0"
    id "org.ajoberstar.git-publish" version "3.0.0"
    id('net.gradleutil.gradle-conf') version('1.1.18')
}
def confGenVersion = '1.1.18'

defaultTasks 'clean', 'shadow'

buildDir = file('./dist')

apply plugin: 'java'

group = 'org.cfmlprojects'
description = 'Daevil Gradle build script'
archivesBaseName = 'daevil'
version = '1.0.1'

sourceCompatibility = 11
targetCompatibility = 11

configurations {
    procrun // for downloading
}


def jteDir = layout.buildDirectory.dir('jteFiles')

tasks.getByName('compileJava').configure {
    sourceSets.main.java.srcDirs += jteDir
    doFirst{
        net.gradleutil.gen.Generator.generate(file('src/main/jte').toPath(), jteDir.get().asFile.toPath(),
                net.gradleutil.gen.Generator.defaultOptions().packageName('daevil'))
    }
}

java {
    withJavadocJar()
    withSourcesJar()
}

shadowJar {
    archiveClassifier.set null
    mergeServiceFiles()
    dependencies {
        exclude(dependency('org.slf4j:slf4j-api'))
        exclude(dependency('com.google.guava:.*'))
    }
    minimize()
    Set<File> jars = []
    eachFile{
        if(it.name.endsWith('.jar')){
            jars.add(it.file as File)
        }
    }
    doLast {
        jars.sort{it.length()}.each{ file ->
            def formatStr = "%,10.2f"
            logger.lifecycle("${String.format(formatStr, file.length() / 1024 / 1024)} Mb " + file.name)
        }
        def jarFile = outputs.files.first() as File
        def formatStr = "%,10.2f"
        logger.lifecycle("Shadow jar:" + jarFile + "${String.format(formatStr, jarFile.length() / 1024)} Mb")
    }
}

test {
    // Enable JUnit 5 (Gradle 4.6+).
    useJUnitPlatform {}

    // Always run tests, even when nothing changed.
    dependsOn 'cleanTest'

    //until fixed for gh actions
    ignoreFailures = true

    // Show test results.
    //testLogging { events "passed", "skipped", "failed" }
    testLogging { events "skipped", "failed" }
    testLogging.exceptionFormat = 'full'
    // show standard out and standard error of the test JVM(s) on the console
    //testLogging.showStandardStreams = true
}


task provisionProcrun(type: Copy) {
    ext {
        destination = file('src/main/resources/script/windows/procrun')
        fileName = ''
    }
    from configurations.procrun
    doFirst {
        configurations.procrun.asFileTree.each {
            println "Extracting ${it} to ${ext.destination}"
            fileName = it.name
            from(zipTree(it))
        }
        delete ext.destination
    }
    into ext.destination
    doLast {
        println "Deleting $ext.destination/${ext.fileName}"
        delete "$ext.destination/${ext.fileName}"
    }
}
//build.dependsOn provisionProcrun

dependencies {
    implementation group: 'org.graylog.repackaged', name: 'os-platform-finder', version: '1.2.3'
    implementation('net.gradleutil:conf-gen:' + confGenVersion)

    procrun group: 'commons-daemon', name: 'commons-daemon', classifier: 'bin-windows', ext: 'zip', version: '1.1.0'

    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
    testImplementation group: 'org.junit.platform', name: 'junit-platform-launcher', version: "1.2.0"
    testImplementation('org.junit.jupiter:junit-jupiter-params:5.8.2')

    implementation 'com.google.guava:guava:31.1-jre'

    implementation 'org.jetbrains.pty4j:pty4j:0.12.7'
    implementation 'net.java.dev.jna:jna:5.11.0'
    implementation 'net.java.dev.jna:jna-platform:5.11.0'

}

repositories {
    mavenCentral()
    mavenLocal()
    maven { url "https://jitpack.io" }
}

task setupDocinfo() {
    ext {
        docinfodir = file(rootProject.buildDir.path + '/docinfo')
    }
    doFirst {
        docinfodir.mkdirs()
//        def css = 'https://raw.githubusercontent.com/darshandsoni/asciidoctor-skins/gh-pages/css/boot-superhero.css'.toURL().text
        def css = 'https://raw.githubusercontent.com/spring-projects/spring-framework/master/src/docs/asciidoc/stylesheets/asciidoctor-spring.css'.toURL().text
//        css += 'https://raw.githubusercontent.com/spring-projects/spring-framework/master/src/docs/asciidoc/stylesheets/main.css'.toURL().text
        file(docinfodir.path + "/docinfo.html").text = """
            <style>
              ${css}
              #toc.toc2{overflow-y:hidden}
              .toc{overflow-y:auto}.toc>.toc-list{overflow:hidden;position:relative}.toc>.toc-list li{list-style:none}.toc-list{margin:0;padding-left:10px}a.toc-link{color:currentColor;height:100%}.is-collapsible{max-height:1000px;overflow:hidden;transition:all 300ms ease-in-out}.is-collapsed{max-height:0}.is-position-fixed{position:fixed !important;top:0}.is-active-link{font-weight:700}.toc-link::before{background-color:#EEE;content:' ';display:inline-block;height:inherit;left:0;margin-top:-1px;position:absolute;width:2px}.is-active-link::before{background-color:#54BC4B}
            </style>
            """.stripIndent()
        file(docinfodir.path + "/docinfo-footer.html").text = '''
            <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.1.1/tocbot.min.js"></script>
            <script>
              var oldtoc = document.getElementById('toctitle').nextElementSibling;
              var newtoc = document.createElement('div');
              newtoc.setAttribute('id', 'tocbot');
              newtoc.setAttribute('class', 'js-toc');
              oldtoc.parentNode.replaceChild(newtoc, oldtoc);
              tocbot.init({ contentSelector: '#content',
                headingSelector: 'h1, h2, h3, h4',
                smoothScroll: false });
              var handleTocOnResize = function() {
                var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
                if (width < 768) {
                  tocbot.refresh({ contentSelector: '#content',
                    headingSelector: 'h1, h2, h3, h4',
                    collapseDepth: 6,
                    activeLinkClass: 'ignoreactive',
                    throttleTimeout: 1000,
                    smoothScroll: false });
                }
                else {
                  tocbot.refresh({ contentSelector: '#content',
                    headingSelector: 'h1, h2, h3, h4',
                    smoothScroll: false });
                }
              };
              window.addEventListener('resize', handleTocOnResize);
              handleTocOnResize();
            </script>
            '''.stripIndent()
    }
}

asciidoctor {
    dependsOn setupDocinfo
    outputDir = file(rootProject.buildDir.path + '/docs')
    sourceDir = file('.')
    sources {
        include 'README.adoc'
    }
    attributes 'source-highlighter': 'coderay', docinfo1: '', docinfodir: setupDocinfo.docinfodir.path
}

task docs() {
    description = 'Convert asciidoc to html'
    outputs.dir(asciidoctor.outputDir)
    dependsOn asciidoctor
    doLast {
        def readmeFile = file("${asciidoctor.outputDir.path}/html5/README.html")
        println "docbook: " + readmeFile
    }
}

task docsView() {
    description = 'Convert asciidoc to html and open with the browser'
    dependsOn docs
    doLast {
        def readmeFile = file("${asciidoctor.outputDir.path}/html5/README.html")
        println "Opening browser to file://" + readmeFile
        project.exec {
            commandLine "xdg-open", readmeFile.toURI()
        }
    }

}

gitPublish {
    branch = 'gh-pages'
    commitMessage = 'Publishing docs'
    contents {
        from("${asciidoctor.outputDir.path}/html5/") {
            eachFile {
                println "Adding ${it} to the gh-pages branch"
            }
            into "."
            rename 'README.html', 'index.html'
        }
    }
}

task docsPublishPush() {
    dependsOn gitPublishPush
    mustRunAfter docs
    doFirst {
        println "Git commit+push: ${gitPublish.commitMessage.get()}"
    }
}

task docsPublish() {
    dependsOn docs, docsPublishPush
}


confConfig{
    conf.set file(System.getProperty("user.home") + '/.cfdistrorc.propertiesss')
    silent.set true
}

apply plugin: 'signing'

ext {
    deployToMaven = System.getenv('SIGNINGKEY') ?: config?.gpg?.cfmlprojects?.signkeyid
    isSnapshot = version.endsWith("SNAPSHOT")
}


if (deployToMaven) {
    signing {
        def signingKey = System.getenv('SIGNINGKEY') ?: config.gpg.cfmlprojects.key
        def signingPassword = System.getenv('SIGNINGPASSWORD') ?: config.gpg.cfmlprojects.pass
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign configurations.archives
    }
} else {
    task signArchives() {
        description = "Add a  with signing info to enbable jar signing"
        doFirst {
            println "Signing is disabled without keys"
        }
    }
}


apply plugin: 'maven-publish'

jar {
    enabled(true)
    archiveClassifier.set('core')
    dependsOn(shadowJar)
}
artifacts { archives javadocJar, sourcesJar }

publishing {
    repositories {
        maven {
            if (project.isSnapshot) {
                url "https://oss.sonatype.org/content/repositories/snapshots"
            } else {
                url "https://oss.sonatype.org/service/local/staging/deploy/maven2"
            }
            if(deployToMaven){
                credentials {
                    username = System.getenv('MAVENCENTRALUSERNAME') ?: config.sonatype.cfmlprojects.user
                    password = System.getenv('MAVENCENTRALPASSWORD') ?: config.sonatype.cfmlprojects.pass
                }
            }
        }
    }
    publications {
        shadow(MavenPublication) { publication ->
            project.shadow.component(publication)
            artifact sourcesJar
            artifact javadocJar
            if (deployToMaven) {
                // create the signed artifacts
                project.tasks.signArchives.signatureFiles.each {
                    artifact(it) {
                        def matcher = it.file =~ /-(sources|javadoc)\.jar\.asc$/
                        if (matcher.find()) {
                            classifier = matcher.group(1)
                        } else {
                            classifier = null
                        }
                        extension = 'jar.asc'
                    }
                }
            }
        }
    }
}

model {
    tasks.generatePomFileForShadowPublication{
        destination = file("$buildDir/generated-pom.xml")
    }
    tasks.publishShadowPublicationToMavenLocal { dependsOn project.tasks.signArchives }
    tasks.publishShadowPublicationToMavenRepository { dependsOn project.tasks.signArchives }
}